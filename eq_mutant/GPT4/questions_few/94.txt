Please analyze the two following provided code files in C or Java. Identify if they are semantically equal. 'Semantically equal' means two codes have the same meaning, that they have the same output given the same input.&#10;Here are three semantically equal examples:  &#10;The first example pair is&#10;``` Code 1&#10;double f(double M, double x) {&#10;    x = (M + x) / 2;&#10;    return x;&#10; }&#10;```&#10;``` Mutant Code 1&#10;double f(double M, double x) {&#10;    x = (M + x++ ) / 2;&#10;    return x;&#10; }&#10;```&#10;Yes. The two codes are semantically euqal because `M + x++` first does `M + x` and then `x++`. Therefore, `(M + x) / 2` is the same with `(M + x++) / 2`.&#10;&#10;&#10;The second example pair is &#10;``` Code 2&#10;double f(int x, int divisor){&#10;   return x*divisor;&#10;}&#10;```&#10;```Mutant Code 2&#10;double f(int x, int divisor){&#10;    return x*divisor++;&#10;}&#10;```&#10;Yes. The two codes are semantically euqal because `x*divisor` first does `x*divisor` and then `divisor++`. The two functions return the same values.&#10;&#10;&#10;The third example pair is &#10;``` Code 3&#10;int f(int a, int y, int x){&#10;    int p = a;&#10;    p = x + y;&#10;    return p;&#10;}&#10;```&#10;``` Mutant Code 3&#10;int f(int a, int y, int x){&#10;    int p = 1;&#10;    p = x + y;&#10;    return p;&#10;}&#10;```&#10;Yes. The two codes are semantically euqal because the local value `p` is re-assigned by `x+y`. There, the change `int p = 1;` will not affect the function.&#10;&#10;  &#10;&#10;Please identify if the two following codes are semantically equal. Please only answer `yes` or `no`. `yes` means they are semantically equal. `no` means they are not. &#10;Input :&#10;    ```Code &#10;// This is a mutant program.&#10;// Author : ysma&#10;&#10;public class QuickSort&#10;{&#10;&#10;    private  void quicksort( int[] data, int first, int last )&#10;    {&#10;        int lower = first + 1;&#10;        int upper = last;&#10;        swap( data, first, (first + last) / 2 );&#10;        int bound = data[first];&#10;        while (lower <= upper) {&#10;            while (bound > data[lower]) {&#10;                lower++;&#10;            }&#10;            while (bound < data[upper]) {&#10;                upper--;&#10;            }&#10;            if (lower < upper) {&#10;                swap( data, lower++, upper-- );&#10;            } else {&#10;                lower++;&#10;            }&#10;        }&#10;        swap( data, upper, first );&#10;        if (first < upper - 1) {&#10;            quicksort( data, first, upper - 1 );&#10;        }&#10;        if (upper + 1 < last) {&#10;            quicksort( data, upper + 1, last );&#10;        }&#10;    }&#10;&#10;    public  void sort( int[] data )&#10;    {&#10;        if (data.length < 2) {&#10;            return;&#10;        }&#10;        int max = 0;&#10;        for (int i = 1; i < data.length; i++) {&#10;            if (data[max] < data[i]) {&#10;                max = i;&#10;            }&#10;        }&#10;        swap( data, data.length - 1, max );&#10;        quicksort( data, 0, data.length - 2 );&#10;    }&#10;&#10;    public  void swap( int[] data, int i, int j )&#10;    {&#10;        int tmp = data[i];&#10;        data[i] = data[j];&#10;        data[j] = tmp;&#10;    }&#10;&#10;}&#10;&#10;```&#10;```Mutant Code &#10;// This is a mutant program.&#10;// Author : ysma&#10;&#10;public class QuickSort&#10;{&#10;&#10;    private  void quicksort( int[] data, int first, int last )&#10;    {&#10;        int lower = first + 1;&#10;        int upper = last;&#10;        swap( data, first, (first + last) / 2 );&#10;        int bound = data[first];&#10;        while (lower <= upper) {&#10;            while (bound > data[lower]) {&#10;                lower++;&#10;            }&#10;            while (bound < data[upper]) {&#10;                 ;&#10;            }&#10;            if (lower < upper) {&#10;                swap( data, lower++, upper-- );&#10;            } else {&#10;                lower++;&#10;            }&#10;        }&#10;        swap( data, upper, first );&#10;        if (first < upper - 1) {&#10;            quicksort( data, first, upper - 1 );&#10;        }&#10;        if (upper + 1 < last) {&#10;            quicksort( data, upper + 1, last );&#10;        }&#10;    }&#10;&#10;    public  void sort( int[] data )&#10;    {&#10;        if (data.length < 2) {&#10;            return;&#10;        }&#10;        int max = 0;&#10;        for (int i = 1; i < data.length; i++) {&#10;            if (data[max] < data[i]) {&#10;                max = i;&#10;            }&#10;        }&#10;        swap( data, data.length - 1, max );&#10;        quicksort( data, 0, data.length - 2 );&#10;    }&#10;&#10;    public  void swap( int[] data, int i, int j )&#10;    {&#10;        int tmp = data[i];&#10;        data[i] = data[j];&#10;        data[j] = tmp;&#10;    }&#10;&#10;}&#10;&#10;```&#10;The difference patch is &#10;&#10;    ```&#10;    @@ -18 +18 @@&#10;-                upper--;&#10;+                 ;&#10;&#10;    ```