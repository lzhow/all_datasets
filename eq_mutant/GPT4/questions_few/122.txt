Please analyze the two following provided code files in C or Java. Identify if they are semantically equal. 'Semantically equal' means two codes have the same meaning, that they have the same output given the same input.&#10;Here are three semantically equal examples:  &#10;The first example pair is&#10;``` Code 1&#10;double f(double M, double x) {&#10;    x = (M + x) / 2;&#10;    return x;&#10; }&#10;```&#10;``` Mutant Code 1&#10;double f(double M, double x) {&#10;    x = (M + x++ ) / 2;&#10;    return x;&#10; }&#10;```&#10;Yes. The two codes are semantically euqal because `M + x++` first does `M + x` and then `x++`. Therefore, `(M + x) / 2` is the same with `(M + x++) / 2`.&#10;&#10;&#10;The second example pair is &#10;``` Code 2&#10;double f(int x, int divisor){&#10;   return x*divisor;&#10;}&#10;```&#10;```Mutant Code 2&#10;double f(int x, int divisor){&#10;    return x*divisor++;&#10;}&#10;```&#10;Yes. The two codes are semantically euqal because `x*divisor` first does `x*divisor` and then `divisor++`. The two functions return the same values.&#10;&#10;&#10;The third example pair is &#10;``` Code 3&#10;int f(int a, int y, int x){&#10;    int p = a;&#10;    p = x + y;&#10;    return p;&#10;}&#10;```&#10;``` Mutant Code 3&#10;int f(int a, int y, int x){&#10;    int p = 1;&#10;    p = x + y;&#10;    return p;&#10;}&#10;```&#10;Yes. The two codes are semantically euqal because the local value `p` is re-assigned by `x+y`. There, the change `int p = 1;` will not affect the function.&#10;&#10;  &#10;&#10;Please identify if the two following codes are semantically equal. Please only answer `yes` or `no`. `yes` means they are semantically equal. `no` means they are not. &#10;Input :&#10;    ```Code &#10;public class Profit {&#10;&#10;double Profit(double i)&#10;{&#10;  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;&#10;  bonus1=100000*0.1;&#10;  bonus2=100000*0.1+100000*0.075;&#10;  bonus4=100000*0.1+100000*0.075+200000*0.05;&#10;  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;&#10;  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;&#10;  if(i<=100000)&#10;    bonus=i*0.1;&#10;    else if(i<=200000)&#10;      bonus=bonus1+(i-100000)*0.075;&#10;        else if(i<=400000)&#10;          bonus=bonus2+(i-200000)*0.05;&#10;            else if(i<=600000)&#10;              bonus=bonus4+(i-400000)*0.03;&#10;                else if(i<=1000000)&#10;                  bonus=bonus6+(i-600000)*0.015;&#10;                    else&#10;                      bonus=bonus10+(i-1000000)*0.01;&#10;return(bonus);&#10;}&#10;	double abs(double a) {&#10;		if (a < 0) return -a;&#10;		return a;&#10;	}&#10;}&#10;&#10;```&#10;```Mutant Code &#10;public class Profit {&#10;&#10;double Profit(double i)&#10;{&#10;  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;&#10;  bonus1=100000*0.1;&#10;  bonus2=100000*0.1+100000*0.075;&#10;  bonus4=100000*0.1+100000*0.075+200000*0.05;&#10;  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;&#10;  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;&#10;  if(i<=100000)&#10;    bonus=i*0.1;&#10;    else if(i<=200000)&#10;      bonus=bonus1+(i-100000)*0.075;&#10;        else if(i<=400000)&#10;          bonus=bonus2+(i-200000)*0.05;&#10;            else if(i<=600000)&#10;              bonus=bonus4+(i-400000)*0.03;&#10;                else if(i<=1000000)&#10;                  bonus=bonus6+(i-600000)*0.015;&#10;                    else&#10;                      bonus=bonus10+(i++-1000000)*0.01;&#10;return(bonus);&#10;}&#10;	double abs(double a) {&#10;		if (a < 0) return -a;&#10;		return a;&#10;	}&#10;}&#10;&#10;```&#10;The difference patch is &#10;&#10;    ```&#10;    @@ -22 +22 @@&#10;-                      bonus=bonus10+(i-1000000)*0.01;&#10;+                      bonus=bonus10+(i++-1000000)*0.01;&#10;&#10;    ```